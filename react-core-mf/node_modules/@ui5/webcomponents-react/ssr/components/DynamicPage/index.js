'use client';

import { debounce, ThemingParameters, useStylesheet, useSyncRef } from '@ui5/webcomponents-react-base';
import { clsx } from 'clsx';
import React, { cloneElement, forwardRef, useEffect, useRef, useState } from 'react';
import { GlobalStyleClasses, PageBackgroundDesign } from '../../enums/index.js';
import { useObserveHeights } from '../../internal/useObserveHeights.js';
import { DynamicPageAnchorBar } from '../DynamicPageAnchorBar/index.js';
import { FlexBox } from '../FlexBox/index.js';
import { classNames, styleData } from './DynamicPage.module.css.js';
import { DynamicPageCssVariables } from './utils.js';
/**
 * Defines the current state of the component.
 */
var HEADER_STATES = /*#__PURE__*/function (HEADER_STATES) {
  HEADER_STATES["AUTO"] = "AUTO";
  HEADER_STATES["VISIBLE_PINNED"] = "VISIBLE_PINNED";
  HEADER_STATES["HIDDEN_PINNED"] = "HIDDEN_PINNED";
  HEADER_STATES["VISIBLE"] = "VISIBLE";
  HEADER_STATES["HIDDEN"] = "HIDDEN";
  return HEADER_STATES;
}(HEADER_STATES || {});
/**
 * The dynamic page is a generic layout control designed to support various floorplans and use cases.
 * The content of both the header and the page can differ from floorplan to floorplan.
 *
 * The header of the dynamic page is collapsible, which helps users to focus on the actual page content, but still ensures that important header information
 * and actions are readily available.
 */
const DynamicPage = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    headerTitle,
    headerContent,
    style,
    backgroundDesign,
    showHideHeaderButton,
    headerContentPinnable,
    alwaysShowContentHeader,
    children,
    className,
    footer,
    a11yConfig,
    onToggleHeaderContent,
    onPinnedStateChange,
    headerCollapsed: headerCollapsedProp,
    preserveHeaderStateOnScroll,
    ...rest
  } = props;
  const {
    onScroll: _1,
    ...propsWithoutOmitted
  } = rest;
  const anchorBarRef = useRef(null);
  const [componentRef, dynamicPageRef] = useSyncRef(ref);
  const contentRef = useRef(null);
  const [componentRefTopHeader, topHeaderRef] = useSyncRef(headerTitle?.ref);
  const [componentRefHeaderContent, headerContentRef] = useSyncRef(headerContent?.ref);
  const scrollTimeout = useRef(0);
  const [headerState, setHeaderState] = useState(alwaysShowContentHeader ? HEADER_STATES.VISIBLE_PINNED : HEADER_STATES.AUTO);
  const isToggledRef = useRef(false);
  const [isOverflowing, setIsOverflowing] = useState(false);
  const [headerCollapsedInternal, setHeaderCollapsedInternal] = useState(headerCollapsedProp);
  // observe heights of header parts
  const {
    topHeaderHeight,
    headerCollapsed
  } = useObserveHeights(dynamicPageRef, topHeaderRef, headerContentRef, anchorBarRef, [headerCollapsedInternal, setHeaderCollapsedInternal], {
    noHeader: false,
    fixedHeader: headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.HIDDEN_PINNED,
    scrollTimeout,
    preserveHeaderStateOnScroll
  });
  useEffect(() => {
    if (preserveHeaderStateOnScroll && headerState === HEADER_STATES.AUTO) {
      if (dynamicPageRef.current.scrollTop <= (topHeaderRef?.current.offsetHeight ?? 0) + Math.max(0, headerContentRef.current.offsetHeight ?? 0 - topHeaderRef?.current.offsetHeight ?? 0)) {
        setHeaderState(HEADER_STATES.VISIBLE);
      } else {
        setHeaderState(HEADER_STATES.HIDDEN);
      }
    }
  }, [preserveHeaderStateOnScroll, headerState]);
  useEffect(() => {
    if (headerCollapsedProp != null) {
      setHeaderCollapsedInternal(headerCollapsedProp);
      onToggleHeaderContentInternal(undefined, headerCollapsedProp);
    }
  }, [headerCollapsedProp]);
  useStylesheet(styleData, DynamicPage.displayName);
  const dynamicPageClasses = clsx(classNames.dynamicPage, GlobalStyleClasses.sapScrollBar, classNames[`background${backgroundDesign}`], className, [HEADER_STATES.HIDDEN, HEADER_STATES.HIDDEN_PINNED].includes(headerState) && classNames.headerCollapsed);
  useEffect(() => {
    const debouncedObserverFn = debounce(([element]) => {
      setIsOverflowing(!element.isIntersecting);
    }, 250);
    const observer = new IntersectionObserver(debouncedObserverFn, {
      root: dynamicPageRef.current,
      threshold: 0.98,
      rootMargin: '0px 0px -60px 0px' // negative bottom margin for footer height
    });
    if (contentRef.current) {
      observer.observe(contentRef.current);
    }
    return () => {
      observer.disconnect();
      debouncedObserverFn.cancel();
    };
  }, []);
  const timeoutRef = useRef(undefined);
  useEffect(() => {
    const dynamicPage = dynamicPageRef.current;
    const oneTimeScrollHandler = e => {
      setHeaderState(HEADER_STATES.AUTO);
      // only collapse the header after it was programmatically expanded, if the header shouldn't be visible
      if (e.target.scrollTop > (topHeaderRef?.current.offsetHeight ?? 0) + Math.max(0, headerContentRef.current.offsetHeight ?? 0 - topHeaderRef?.current.offsetHeight ?? 0)) {
        setHeaderCollapsedInternal(true);
      }
    };
    if (!preserveHeaderStateOnScroll && (headerState === HEADER_STATES.VISIBLE || headerState === HEADER_STATES.HIDDEN)) {
      // only reset state after scroll if scroll isn't invoked by expanding the header
      const timeout = scrollTimeout.current - performance.now();
      clearTimeout(timeoutRef.current);
      if (timeout > 0) {
        timeoutRef.current = setTimeout(() => {
          dynamicPage?.addEventListener('scroll', oneTimeScrollHandler, {
            once: true
          });
        }, timeout + 50);
      } else {
        dynamicPage?.addEventListener('scroll', oneTimeScrollHandler, {
          once: true
        });
      }
    }
    return () => {
      dynamicPage?.removeEventListener('scroll', oneTimeScrollHandler);
    };
  }, [dynamicPageRef, headerState, preserveHeaderStateOnScroll]);
  const onToggleHeaderContentInternal = (e, headerCollapsedProp) => {
    e?.stopPropagation();
    if (!isToggledRef.current) {
      isToggledRef.current = true;
    }
    onToggleHeaderContentVisibility(headerCollapsedProp ?? !headerCollapsed);
  };
  const onToggleHeaderContentVisibility = localHeaderCollapsed => {
    scrollTimeout.current = performance.now() + 500;
    setHeaderState(oldState => {
      if (oldState === HEADER_STATES.VISIBLE_PINNED || oldState === HEADER_STATES.HIDDEN_PINNED) {
        return localHeaderCollapsed ? HEADER_STATES.HIDDEN_PINNED : HEADER_STATES.VISIBLE_PINNED;
      }
      return localHeaderCollapsed ? HEADER_STATES.HIDDEN : HEADER_STATES.VISIBLE;
    });
  };
  useEffect(() => {
    if (headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.VISIBLE) {
      setHeaderCollapsedInternal(false);
    } else if (headerState === HEADER_STATES.HIDDEN_PINNED || headerState === HEADER_STATES.HIDDEN) {
      setHeaderCollapsedInternal(true);
    }
  }, [headerState]);
  const onHoverToggleButton = e => {
    if (topHeaderRef.current) {
      topHeaderRef.current.style.backgroundColor = e?.type === 'mouseover' ? ThemingParameters.sapObjectHeader_Hover_Background : null;
    }
  };
  const handleHeaderPinnedChange = headerWillPin => {
    if (headerWillPin) {
      setHeaderState(HEADER_STATES.VISIBLE_PINNED);
    } else {
      setHeaderState(HEADER_STATES.VISIBLE);
    }
  };
  useEffect(() => {
    if (alwaysShowContentHeader !== undefined) {
      if (alwaysShowContentHeader) {
        setHeaderState(HEADER_STATES.VISIBLE_PINNED);
      } else {
        setHeaderState(HEADER_STATES.VISIBLE);
      }
    }
  }, [alwaysShowContentHeader]);
  const onDynamicPageScroll = e => {
    if (preserveHeaderStateOnScroll) {
      return;
    }
    if (!isToggledRef.current) {
      isToggledRef.current = true;
    }
    if (typeof props?.onScroll === 'function') {
      props.onScroll(e);
    }
    if (headerState === HEADER_STATES.HIDDEN_PINNED && e.target.scrollTop === 0) {
      setHeaderState(HEADER_STATES.VISIBLE_PINNED);
    }
  };
  const dynamicPageStyles = {
    ...style
  };
  if (headerCollapsed === true && headerContent) {
    scrollTimeout.current = performance.now() + 200;
    dynamicPageStyles[DynamicPageCssVariables.titleFontSize] = ThemingParameters.sapObjectHeader_Title_SnappedFontSize;
  }
  useEffect(() => {
    if (typeof onToggleHeaderContent === 'function' && isToggledRef.current) {
      onToggleHeaderContent(headerCollapsed !== true);
    }
  }, [headerCollapsed]);
  const top = headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.VISIBLE ? (headerContentRef?.current?.offsetHeight ?? 0) + topHeaderHeight : topHeaderHeight;
  return /*#__PURE__*/React.createElement("div", {
    ref: componentRef,
    className: dynamicPageClasses,
    style: dynamicPageStyles,
    onScroll: onDynamicPageScroll,
    ...propsWithoutOmitted
  }, headerTitle && /*#__PURE__*/cloneElement(headerTitle, {
    'data-not-clickable': alwaysShowContentHeader && !headerContentPinnable || !headerContent || !showHideHeaderButton && !headerContentPinnable,
    ref: componentRefTopHeader,
    className: clsx(classNames.title, headerTitle?.props?.className),
    onToggleHeaderContentVisibility: onToggleHeaderContentInternal,
    'data-header-content-visible': headerContent && headerCollapsed !== true
  }), headerContent && /*#__PURE__*/cloneElement(headerContent, {
    ref: componentRefHeaderContent,
    style: headerCollapsed === true ? {
      ...headerContent.props.style,
      position: 'relative',
      visibility: 'hidden'
    } : headerContent.props.style,
    className: clsx(classNames.header, headerContent?.props?.className),
    headerPinned: preserveHeaderStateOnScroll || headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.VISIBLE,
    topHeaderHeight
  }), /*#__PURE__*/React.createElement(FlexBox, {
    "data-component-name": "DynamicPageAnchorBarContainer",
    className: classNames.anchorBar,
    ref: anchorBarRef,
    style: {
      top
    }
  }, /*#__PURE__*/React.createElement(DynamicPageAnchorBar, {
    headerContentPinnable: headerContentPinnable,
    showHideHeaderButton: showHideHeaderButton,
    headerContentVisible: headerContent && headerCollapsed !== true,
    headerPinned: headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.HIDDEN_PINNED,
    a11yConfig: a11yConfig,
    onHoverToggleButton: onHoverToggleButton,
    onToggleHeaderContentVisibility: onToggleHeaderContentInternal,
    onPinnedStateChange: onPinnedStateChange,
    setHeaderPinned: handleHeaderPinnedChange
  })), /*#__PURE__*/React.createElement("div", {
    ref: contentRef,
    "data-component-name": "DynamicPageContent",
    className: classNames.contentContainer,
    style: {
      paddingBlockEnd: footer ? '1rem' : 0
    }
  }, typeof children === 'function' ? children({
    stickyHeaderHeight: top + 1 /*anchorBar height */
  }) : children), footer && /*#__PURE__*/React.createElement("div", {
    className: classNames.footer,
    style: {
      position: isOverflowing ? 'sticky' : 'absolute'
    },
    "data-component-name": "DynamicPageFooter",
    role: a11yConfig?.dynamicPageFooter?.role ?? 'contentinfo',
    "aria-label": a11yConfig?.dynamicPageFooter?.['aria-label'],
    "aria-labelledby": a11yConfig?.dynamicPageFooter?.['aria-labelledby']
  }, footer));
});
DynamicPage.displayName = 'DynamicPage';
DynamicPage.defaultProps = {
  backgroundDesign: PageBackgroundDesign.Solid,
  showHideHeaderButton: true,
  headerContentPinnable: true
};
export { DynamicPage };